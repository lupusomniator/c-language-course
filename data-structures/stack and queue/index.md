Стек и очередь – это две основные структуры данных, которые используются в программировании для организации хранения и обработки данных. В данной статье мы рассмотрим основные операции со стеком и очередью, а также способы их реализации с помощью массивов и структур.
# Стек
## Определение
**Стек** — это структура данных, представляющий собой последовательность элементов, организованная по принципу LIFO (Last Input – First Output, «последний пришёл, первый вышел»). Это значит, что мы будем иметь доступ только к последнему добавленному элементу.

Примером стека может быть коробка с печеньем. Для того, чтобы получить печеньку, которая где-то посередине, вам нужно будет сначала съесть все печеньки над ней. 

![test](images/mem_cookies.png)
## Основные операции 
1. Push – добавление элемента в стек; 
2. Pop – удаление элемента из стека; 
3. Top – получение верхнего элемента стека; 
4. Empty – проверка на пустоту стека;
## Реализация при помощи одномерного массива
Для реализации стека необходимо создать массив фиксированного размера и переменную, которая будет указывать на вершину стека.

Отличительная особенность этого способа – простота реализации и максимальная скорость выполнения. Такой стек может применяться в том, случае, когда его максимальный размер известен заранее или известно, что он мал.
```
#define MAX_LEN 100

typedef struct TStack {
    int Cookies [MAX_LEN];
    int Top;
} TStack;
```
#### Инициализация стека
Индекс элемента, находящегося в вершине стека, равен 0.
```
void Init(TStack *stack) {
    stack->Top = 0;
}
```
#### Добавление элемента в стек
При добавлении элемента в стек необходимо увеличить значение переменной указателя на единицу и записать элемент в соответствующую ячейку массива. 
```
void Push(TStack *stack, int value){
    if (stack->Top < MAX_LEN){
        stack->Cookies[stack->Top] = value;
        stack->Top++;
    }
    else {
        printf("Коробка заполнена :)\n");
    }
}
```
#### Удаление элемента из стека
Если в массиве, соответствующем стеку, есть элементы, то количество элементов уменьшается на 1. После этого возвращается последний элемент.
```
int Pop(TStack *stack){
    if (stack->Top > 0){
        stack->Top--;
        return stack->Cookies[stack->Top];
    }
    else {
        printf("Коробка пуста :(\n");
        return 0;
    }
}
```
#### Получение верхнего элемента стека
```
int Top(TStack *stack){
    if (stack->Top > 0){
        return stack->Cookies [stack->Top-1];
    } 
    else {
        printf("Коробка пуста :(\n");
        return 0;
    }
}
```
#### Проверка, пуст ли стек
Если количество элементов в стеке равно 0, то стек пуст.
```
int Empty(TStack *stack) {
    if (stack->Top == 0){
        return 1;
    }   
    else {
        return 0;
    }
}
```
## Реализация при помощи односвязного списка
Для реализации стека мы можем использовать односвязный список, в котором каждый новый элемент добавляется в начало списка и удаление элементов происходит с начала списка. Первый узел имеет NULL в поле ссылки, второй узел имеет адрес первого узла в поле ссылки и так далее, а адрес последнего узла находится в “верхнем” указателе. 
```
typedef struct TStack {
    int Value;
    struct TStack *Next;
} TStack;
```
#### Добавление элемента в стек
Функция вставки первого элемента проста: создаём новый узел. Указатель Next кидаем на старый узел. Далее указатель на вершину стека перекидываем на вновь созданный узел. Теперь вершина стека указывает на новый узел.
```
void Push(TStack *top_cookie, int value) {
    TStack *tmp = malloc(sizeof(TStack));
    if (tmp == NULL) {
        printf("Коробка заполнена :)\n");
        return;
    }
    tmp->Next = top_cookie;
    tmp->Value = value;
    top_cookie = tmp;
}
```
#### Удаление элемента из стека
Функция Pop берёт первый элемент (тот, на который указывает вершина), перекидывает указатель на следующий элемент и возвращает первый.
```
TStack* Pop(TStack *top_cookie) {
    TStack *out;
    if (top_cookie == NULL) {
        printf("Коробка пуста :(\n");
        return NULL;
    }
    out = top_cookie;
    top_cookie = top_cookie->Next;
    return out;
}
```
#### Проверка, пуст ли стек
Теперь вместо проверки на длину массива везде используется проверка на равенство NULL вершины стека.
```
int Empty(TStack *top_cookie) {
    return top_cookie == NULL;
}
```
#### Получение верхнего элемента стека
```
int Top(TStack *top_cookie) {
    if (!Empty(top_cookie)) {
        return top_cookie->Value;
    }
    else {
        printf("Коробка пуста :(\n");
        return 0;
    }
}
```
# Очередь
## Определение
**Очередь** – это структура данных, представляющая собой последовательность элементов, образованная по принципу FIFO (First Input – First Output, "первый пришёл – первый вышел").  То есть поместить элемент можно только в конец очереди, а взять элемент только из ее начала.
Примером может служить обыкновенная очередь в магазине. Последний занял последним и будешь, а первый первым ее и покинет.

![test1](images/mem_queue.png)
## Основные операции 
1. Enqueue - добавление элемента в очередь; 
2. Dequeue - удаление элемента из очереди; 
3. Front – получение первого элемента очереди; 
5. Empty - проверка, пуста ли очередь;
## Реализация при помощи одномерного массива
Для реализации очереди мы также как и для стека можем использовать одномерный массив, но добавление элементов будет происходить в конец массива, а удаление элементов - в начале массива. Для этого понадобится создать две дополнительные переменные Front и Rear. Front будет указывать на первый элемент очереди, a Rear на последний элемент.
```
#define MAX_LEN 100

typedef struct TQueue {
    int TQueue[MAX_LEN];
    int Rear;
    int Front;
} TQueue;
```
#### Инициализация очереди
В начале мы инициализируем Front и Rear как 1 и 0.
```
void Init(TQueue *queue) {
    queue->Front = 1;
    queue->Rear = 0;
    return;
}
```
#### Добавление элемента в очередь
При добавлении элемента в очередь указатель Rear смещается на одну позицию вперед, и элемент помещается в соответствующую ячейку массива.
```
void Enqueue (TQueue *queue, int value) {
    if (queue->Rear < MAX_LEN-1) {
        queue->Rear++;
        queue->Queue[queue->Rear] = value;
    }
    else
        printf("Очередь полна :(\n");
    return;
}
```
#### Проверка, пуста ли очередь
Очередь пуста, если указатель на первый элемент равен указателю на последний элемент очереди.
```
int Empty(TQueue *queue) {
    if (queue->Rear < queue->Front){
        return 1;
    }    
    else {
        return 0;
    }
}
```
#### Удаление элемента из очереди
При удалении элемента указатель Front смещается на одну позицию вперед, и элемент считывается из соответствующей ячейки.
```
int Dequeu(TQueue *queue) {
    int value;
    if (Empty(queue) == 1) {
        printf("Очередь пуста :)\n");
        return 0;
    }
    value = queue->Queue[queue->Front];
    queue->Front++;
    return value;
}
```
#### Получение первого элемента очереди
```
int Front(TQueue *queue){
    if (Empty(queue) == 1) {
        printf("Очередь пуста :)\n");
        return 0;
    }
    else {
        return queue->Queue[queue->Front];
    }
}
```
## Реализация очереди c помощью двусвязного списка
Для реализации очереди с помощью двусвязного списка мы будем использовать два указателя: указатель на начало очереди Head и указатель на конец очереди Tail. 
```
typedef struct TQueue {
    struct TListNode {
        int Value;
        struct TListNode *Next;
    };
    struct TListNode *Head;
    struct TListNode *Tail;
} TQueue;
```
#### Инициализация очереди
В начале присвоим им значение NULL.
```
void Init(TQueue *queue) {
    queue->Head = NULL;
    queue->Tail = NULL;
}
```
#### Проверка, пуста ли очередь
Если указатель на начало очереди равен NULL, очередь пуста.
```
int Empty(TQueue *queue) {
    if(queue->Head == NULL){
        return 1;
    }
    else {
        return 0;
    }
}
```
#### Добавление элемента в очередь
При добавлении нового элемента в очередь необходимо создать новый узел и добавить его в конец списка, обновляя при этом указатель на конец очереди. 
```
void Enqueue(TQueue *queue, int value) {
    if (Empty(queue) == 1) {
        queue->Head = queue->Tail = (struct TListNode*)malloc(sizeof(struct TListNode));
        queue->Head->Value = value;
        queue->Head->Next = NULL;
    }
    else {
        queue->Tail->Next = (struct TListNode*)malloc(sizeof(struct TListNode));
        queue->Tail = queue->Tail->Next;
        queue->Tail->Value = value;
        queue->Tail->Next = NULL;
    }
}
```
#### Удаление элемента из очереди
При удалении элемента из очереди мы будем удалять первый узел и обновлять при этом указатель на начало очереди.
```
int Dequeue(TQueue *queue) {
    TQueue *tmp;
    int value;
    if (Empty(queue) == 1) {
        printf("Очередь пуста :)\n");
        return 0;
    }
    value = queue->Head->Value;
    tmp = queue->Head;
    queue->Head = queue->Head->Next;
    free(tmp);
    return value;
}
```
#### Получение первого элемента в очереди 
```
int Front(TQueue *queue) {
    int value;
    value = queue->Head->Value;
    return value;
}
```
В заключение, стек и очередь - это две основные структуры данных, которые используются в программировании для организации хранения и доступа к данным. Они могут быть реализованы с помощью массивов или списков, в зависимости от требований к производительности и функциональности приложения.
