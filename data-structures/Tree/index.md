# (╯ ° □ °) ╯ (┻━┻) Дерево, как частный вид графа. Способы представления деревьев в ЭВМ: левая и правая скобочная запись, список предков, указатели.

**Дерево(в теории графов)** — это связный ациклический граф. Связность означает наличие маршрута между любой парой вершин, ацикличность — отсутствие циклов. 
Отсюда, в частности, следует, что число рёбер в дереве на единицу меньше числа вершин, а между любыми парами вершин имеется один и только один путь.

## Свойства
- Дерево не имеет кратных рёбер и петель.
- Любое дерево с **n** вершинами содержит **n-1** ребро. Более того, конечный связный граф является деревом тогда и только тогда, когда **B-P=1**, где **B** — число вершин, **P** — число рёбер графа.
- Граф является деревом тогда и только тогда, когда любые две различные его вершины можно соединить единственной простой цепью.
- Любое дерево однозначно определяется расстояниями (длиной наименьшей цепи) между его концевыми (степени 1) вершинами.
- Любое дерево является двудольным графом.
- Любое дерево, множество вершин которого не более чем счётное, является планарным графом.
- Для любых трёх вершин дерева, пути между парами этих вершин имеют ровно одну общую вершину.

## Способы представления деревьев в ЭВМ
Дерево является двумерной структурой, но во многих ситуациях удобно пользоваться лишь одномерными структурами данных. 
Поэтому, мы заинтересованы в том, чтобы иметь для деревьев одномерные представления, сохраняющие всю информацию, которая содержится в двумерных картинках. 
Под этим мы подразумеваем, что двумерную картинку можно воспроизвести по ее одномерному представлению

### Левая и правая скобочная запись
Левое скобочное представление дерева **Т** (обозначается **Lrep (T)**) можно получить, применяя к нему следующие рекурсивные правила:
- Если корнем дерева **Т** служит вершина а с прямыми потомками, которые являются корнями поддеревьев **Т1, Т2, ... , Тn**, расположенными в этом порядке, то:
**Lrep (Т) = a (Lrep (Т1), Lrep (Т2), ... , Lrep (Тn))**
- Если корнем дерева **Т** служит вершина **а**, не имеющая прямых потомков, то:
**Lrep (T) = а**.

Правое скобочное представление дерева **Т** (обозначается **Rrep (Т)**) описывается аналогично:
- Если корнем дерева **Т** служит вершина **а** с прямыми потомками, которые являются корнями поддеревьев **Т1, Т2, ... , Тn**, расположенными в этом порядке, то:
**Rrep (T) = (Rrep (Т1), Rrep (Т2), ... , Rrep (Тn)) а**.
- Если корнем дерева **Т** служит вершина **а**, не имеющая прямых потомков, то
**Rrep (Т) = а**.

Заметам, что левое скобочное представление соответствует прямому обходу дерева, а правое - обратному.

###Пример###

![Рис. 412](https://upload.wikimedia.org/wikipedia/commons/thumb/6/60/Depth-first_tree.svg/525px-Depth-first_tree.svg.png "Кораблик")

Правое скобочное представление для дерева на иллюстрации: **(((4 5)3 6)2 7 ((10 11)9 12)8)1**

### Список предков
Пусть дерево имеет **n** вершин, и вершины дерева пронумерованы числами от **1** до **n**. 
Список прямых предков составляется следующим образом. Для вершин дерева с номерами **1, 2,..., n** в этом же порядке перечисляются их прямые предки. 
Будем считать, что предком корня является **0**.
###Пример###
Рассмотрим дерево на рис. 915, и построим для него список прямых предков. 
Для этого создадим массив, индексы которого изменяются от **1** до **n**, где **n** - количество вершин в дереве. 
Вершины дерева уже пронумерованы числами от **1** до **n** в произвольном порядке. 
Заполним наш массив числами по следующему правилу: в ячейку с номером **і** записывается номер вершины, которая является прямым предком вершины с номером **І**.

![Рис. 915](https://vuzdoc.org/htm/img/18/289/43.png "Велосипед")

**Рис. 915**
Полученный массив будет содержать нужный нам список, который для данного примера будет выглядеть:

|Index|    0  |  1  |   2  |   3  |   4  |   5  |   6  |   7  |   8  |   9  |  10  |  11  |
|:----|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
|Value|    9  |  11 |  11  |   3  |   2  |   2  |   3  |   6  |   3  |   6  |   0  |   9  |
### Указатели

Итак, будем представлять ребра дерева указателями.

![Рис. 917](https://habrastorage.org/r/w1560/storage2/1bd/5c6/8e7/1bd5c68e7655756193612eed910ab2a3.jpg "Хабд")

Еще одна проблема — исходящая степень узла дерева может быть произвольной (вплоть до размера используемого алфавита). 
Для решения этой проблемы применим стандартный прием, а именно, будем хранить в каждом узле список дочерних узлов. 
Список будет односвязным и хранить в узле мы будем только голову списка **(старшая дочь)**. 
Это позволит нам заодно отказаться от пустого корня. 
Теперь дерево будет представляться указателем на голову списка дочерних узлов старого корня (т.е. мы заменяем **дерево** на **лес**). 
Таким образом, каждый узел теперь будет содержать ровно два указателя: **link** — на старший дочерний узел, **next** — на свою младшую сестру. 
На следующем рисунке показан процесс такой трансформации, **синие стрелки** соответствуют указателям **link**, **красные** — указателям **next**.

![Рис. 1017](https://habrastorage.org/r/w1560/storage2/2b1/1e1/109/2b11e1109cc39e70e87ae728a948dd81.jpg "Хард")

В дальнейшем, для понимания логики работы с деревом полезно в уме держать схему, показанную на рисунке слева, 
в то время, как реальное представление дерева будет таким, как показано справа.

Вот так, незаметно, мы перешли от дерева с переменной исходящей степенью (дерево общего вида) к двоичному дереву, 
в котором роль указателей на правое и левое поддеревья играют указатели link и next. Следующая картинка наглядно это демонстрирует.

![Рис. 1036](https://habrastorage.org/r/w1560/storage2/8c9/468/67c/8c946867cd7bec02a0ecbfc37771166b.jpg "Яблоко")

Теперь можно перейти и к реализации.
Узел дерева — это

- **Данные**: цепочка символов **key**, ее длина **len** (цепочка не обязана заканчиваться терминальным символов, 
поэтому нужно явно знать ее длину)
- Два указателя **link** и **next**

```C
  struct Node{
    char* key;
    int len;
    struct Node* link;
    struct Node* next;
  }
```
