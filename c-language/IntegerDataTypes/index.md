# Целочисленные типы данных
____
Предназначены для представления в памяти компьютера обычных целых чисел. 
В языке Си есть несколько целочисленных типов данных. Каждый из них имеет разный размер и диапазон значений. Стоит отметить, что целочисленный тип включает в себя **перечислимый (enum)**, **логический (bool) и символьный (char)** типы данных.

*Перечислимый **enum** - тип данных, чьё множество значений представляет собой ограниченный список идентификаторов. Его ранг совпадает с рангом совместимого с ним целого типа, т.е. целого типа, используемого для хранения значений enum.

*Ранг **bool** ниже ранга любого другого целого типа.

Ранги отделены и расположены в таблице по возрастанию, снизу вверх.

|   Тип	| Размер (в байтах) 	|  Диапазон значений 	|
|:---:	|:---:	|:---:	|
|   long long int	|  8 	| от  -(2^63) до (2^63)-1	|
| unsigned long long int| 8| от 0 до (2^64)-1|
| | | |
|   unsigned long int	|4|   от  0 до 4 294 967 295  |
| long int  	|   4	|  от -2 147 483 648 до 2 147 483 647 	|
| | | |
|   unsigned int 	|   4	|    от 0 до 4 294 967 295|
|  int 	|   4	|   	от	-2 147 483 648 до 2 147 483647 |
| | | |
|  unsigned short 	|  2 	|   от 0 до 65 535	|
|   short	|   2	|  от -32 768 до 32 767 |
|  unsigned char 	|   1	|   от 0 до 255	|
| char   	|   1	|   от -128 до 127	|
| | | |
| bool | 1 | false, true|
_____
# Операции над значениями целочисленных типов
1. **Арифметические операции**: сложение (+), вычитание (-), умножение (*), деление (/) и остаток от деления (%).
2. Операции **инкремента** (++) и **декремента** (--).
3. **Операции сравнения**: равно (==), не равно (!=), меньше (<), больше (>), меньше или равно (<=) и больше или равно (>=).
4. **Побитовые операции**: И (&), ИЛИ (|), исключающее ИЛИ (^), сдвиг влево (<<) и сдвиг вправо (>>).
5. **Унарные операции**: отрицание (!) и побитовое НЕ (~).
6. **Логические операции**: И (&&) и ИЛИ (||).
7. **Тернарный оператор условия** (? :).
___
# Преобразование целочисленных типов
В языке Си существует ***явное*** и ***неявное*** преобразование типов.


Если какое-то значение нужно привести к другому типу, нужно перед этим значением в скобках написать название требуемого типа. Это и называется ***явным*** преобразованием.  

***Неявное*** или преобразование ***"по умолчанию"*** происходит автоматически, когда операнды выражения имеют разные типы. Компилятор автоматически приводит их к более широкому типу.


◦ Целочисленное повышение, т.е преобразование меньшего типа в больший тип (зависит от диапазона значений или ранга).

*Например, если у нас есть переменные типа short и int, то при выполнении операций между ними тип short будет автоматически преобразован в тип int, так как он имеет больший диапазон значений.*

◦ Преобразование знаковых типов в беззнаковые. В этом случае значения могут измениться.

*Например, при выполнении операции деления между переменными типа int и unsigned int, компилятор автоматически приводит оба операнда к типу unsigned int, что может привести к некорректным результатам.*

◦ Преобразование типа int в тип bool при использовании в условных выражениях (например, в операторе if). В этом случае любое ненулевое значение будет преобразовано в true, а ноль - в false.

◦ Преобразование целочисленного типа к типу с плавающей точкой

# Целочисленная машинная арифметика

*Целые машинные числа* со знаком объявляются как тип **intN**,
а машинные целые числа без знака объявляются как тип **uintN**, где N — ширина (4, 8, 16, 32 или 64).

Машинные целые числа представляют собой двоичные числа размера N, а также машинные переменные могут быть объявлены как глобальные или локальные. 

Арифметика машинных чисел включает в себя операции *сложения, вычитания, умножения и деления*. При выполнении этих операций может произойти **переполнение**,
когда результат операции выходит за пределы допустимого диапазона значений.
 
Пример: сложим числа 1110 и 0001. Начинаем с младших разрядов.
1) 0 + 1 дает 1, переноса нет.
2) 1 + 1 даст нам 0, и делаем *перенос* единицы в старший разряд.
3) 1 + 1 + 1 дает 1, и делаем *перенос* единицы в старший разряд.
4) 1 + 0 + 1 дает 0, и делаем *перенос* единицы.

Но проблема в том, что у нас не существует более старшего разряда, куда бы мы поместили единицу, так как длина равна 4.
Результат сложения (10101) не вмещается в наперед заданное количество разрядов. Это и есть **переполнение**.

Если мы складываем два положительных числа, и результат превышает максимальное значение, то произойдет перенос старшего бита в следующий разряд и остаток отбрасывается.
Если же мы складываем два отрицательных числа, и результат меньше минимального значения, то также произойдет перенос.

# Знаковый разряд

Знаковый разряд используется для определения знака числа.
Число представляется путем представления старшего (самого левого) разряда числа в качестве знакового. 
Принято считать, что 0 в знаковом разряде означает знак «плюс», а 1 – знак «минус».


# Дополнительный код

Дополнительный код используется для представления отрицательных чисел. Это используется для упрощения алгоритма вычислений, например для того же сложения двух чисел. Поэтому, если в первом разряде находится 1, то мы имеем дело с отрицательным числом.
**Дополнительный код представляет собой инверсию всех битов числа и добавление к нему 1.**

*Например, дан прямой код вида 1 0001100. Инвертируем все, кроме старшего разряда, и получаем 1 1110011. Далее прибавим единицу и получим 1 1110100. Это будет называться дополнительным кодом числа.*

◦ **Прямой код** – это представление числа в двоичной системе счисления, при котором первый (старший) разряд отводится под знак числа.


Вывод: дополнительный код позволяет выполнять арифметические операции с отрицательными числами, не используя дополнительную логику и условия.




