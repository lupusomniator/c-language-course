# Макросы
## Что есть макросы?
В языках С и С++ есть такой механизм, как [препроцессор](https://www.google.ru/).
Он обрабатывает исходный код программы ДО того, как она будет скомпилирована.
У препроцессора есть свои директивы, такие как #include, #pragma, #if и тд. Но нам интересн/а только директива #define.

## Виды макросов
### Самые простые, объекто-подобные(Object-like Macro)
В языке Си довольно распространенной практикой является объявление глобальных констант с помощью директивы #define:
```c
#define PI 3.14159
```
А потом, на этапе препроцессинга, все использования PI будут заменены указанным в объявлении макроса токеном:
```c
double area = 2 * PI * r * r;
```
После препроцессинга, который по сути является банальной подстановкой, это выражение превратится в:
```c
double area = 2 * 3.14159 * r * r;
```
PI - макрос, в самом простом его исполнении. 
Естественно, макросы в таком виде не работают как переменные. Им нельзя присваивать новое значение или использовать их адрес.
```c
// Так нельзя:
PI = 3;          // после препроцессинга: 3.14159 = 3
int *x = &PI;    // после препроцессинга: int *x = &3.14159
```
О макросах важно понимать, что область видимости у них такая же, 
как у нестатических функций в языке Си, то есть они видны везде, куда их "заинклюдили". Однако в отличии от функций, объявление макроса можно отменить:
```c
#undef PI
```
После этой строчки обращаться к PI будет уже нельзя.

### Макросы с параметрами(Function-like Macro)
В этом случае мы можем задать макроопределение с параметрами в следующей форме:
```c
#define имя_макроса(список_параметров) последовательность_символов
```
Список_параметров здесь это список идентификаторов, разделенных запятыми. Между именем макроса и открывающей скобкой не должно быть пробелов.

Для обращения к макросу применяется конструкция:
```c
имя_макроса(список_аргументов)
```
Список_аргументов - это набор значений, которые передаются для каждого параметра макроса.
Примеры:
```c
#define MAX(a, b) a > b ? a : b
#define MIN(a, b) a < b ? a : b

```
### Макросы в несколько строк(Multi-line Macro)
Макросы также можно записывать в несколько строк, но тогда каждая строка, кроме последней, должна заканчиваться символом '\':
```c
#define SWAP(a, b) ({  \
  typeof(a) tmp = a;   \
  a = b;               \
  b = tmp; })
```
### Цепной макрос(Chain Macro)
Сначала компилятор расширяет внешний макрос, а затем внутренний.
В приведенном ниже коде сначала мы расширяем значение TOTAL, затем NUM, а затем MAX.
```c
#define TOTAL NUM
#define NUM MAX
#define MAX 5

int main() {
    int sum = 0;
    for (int i = 0; i < NUM; i++)
        sum++;
    for (int i = 0; i < MAX; i++)
        sum++;
    for (int i = 0; i < TOTAL; i++)
        sum++;
    printf("%d", sum);

    return 0;
}
```
На самом деле можно расположить их и в другом порядке, ничего не поломаеться
```c
#define TOTAL NUM
#define MAX 5
#define NUM MAX
```
## Препроцессорные операции
При обработки исходного кода препроцессор может выполнять две операции: # и ##.

Операция # позволяет заключать текст параметра(превращает переменную в строку), который следует после операции, в кавычки:
```c
#include <stdio.h>
#define print_int(n) printf(#n"=%d \n",n);
 
int main(void)
{
    int x = 23;
    print_int(x);       // x=23
    int y = 14;
    print_int(y);       // y=14
    int number = 203;
    print_int(number);  // number=203
    return 0;
}
```
Директива ## позволяет объединять две [лексемы](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81_%D0%B8_%D1%81%D0%B5%D0%BC%D0%B0%D0%BD%D1%82%D0%B8%D0%BA%D0%B0_%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0_%D0%A1%D0%B8):
```c
#include <stdio.h>
#define print(a,b,c) printf("%d", a##b##c);
 
int main(void)
{
    print(2, 81, 34);   // 28134
    return 0;
}
```
## Техника безопасности при работе с макросами
### 1. Параметрами макросов не должны быть выражения и вызовы функций.
Показательные примеры:
#### Передача выражений
```c
#define MULTIPLY(x) (x * 5)
MULTIPLY(x + 5);
```
```
x = 5;
MULTIPLY(x + 5) -> (x + 5 * 5) //в итоге x не 50, а 30
```
```c
#define ABS(x) ((x) < 0 ? -(x) : (x))
x = 5;
result = ABS(x++);
// ожидаем result = 5, x = 6
// получаем result = 6, x = 7
```
```
ABS(x++) -> ((x++) < 0 ? - (x++): (x++))
```
Как видно, x увеличивается на единицу в первый раз при проверке 
и во второй раз при определении результата, что и приводит к соответствующим итогам.
#### Передача функций
```c
#include <stdio.h>

#define MIN(a, b) ((a) < (b) ? (a) : (b))

int sum_chars(char *chars)
{
  if ((*chars) == '\0') return 0;

  return sum_chars(chars + 1) + (*chars);
}

int main(int argc, char *argv[])
{
  char *str1 = "Hello world";
  char *str2 = "Not so fast";

  int minCharSum = MIN(sum_chars(str1), sum_chars(str2));
  printf("MIN CHARS: %d\n", minCharSum);
}
```
Здесь определена рекурсивная функция sum_chars.
Она вызывается один раз для первой строки (str1) и другой раз — для второй (str2). 
Но, если передать вызовы функций, как аргументы для макроса, будет выполнено три рекурсивных вызова вместо двух. 
Для больших структур данных это станет узким местом производительности. 
Особенно, если макрос используется внутри рекурсивной функции.
### 2. Все аргументы макроса и сам макрос должны быть заключены в скобки.

```c
#define MAX(a, b) a > b ? a : b
int result = 5 + MAX(1, 4);
//ожидаем 9
//получаем 1
```
```c
int result = 5 + 1 > 4 ? 1 : 4;

//Исправленный макрос
#define MAX(a, b) ((a) >= (b) ? (a) : (b))
```
### 3. Многострочные макросы должны иметь свою область видимости.
```c
#define MACRO() doSomething(); \
  doSomethinElse();
```
Подставляем например сюда
```c
if (some_condition) MACRO()
```
```c
if (some_condition) doSomething();
doSomethinElse();
//в условии if выполняеться только первая функция
//это не то что мы хотели получить
```
Исправленный вариант:
```c
#define MACRO() do { \
    doSomething(); \
    doSomethingElse(); \
  } while(0)
if (some_condition) MACRO();
//теперь обе функции выполняються в пределах if
```

# Ссылки откуда я это скатал:
https://habr.com/ru/articles/546946/


https://tproger.ru/translations/c-macro/


https://metanit.com/c/tutorial/3.4.php


https://www.studytonight.com/post/what-are-macros-in-c-language-and-its-types?ref=recent_list

### Оглавление:)

#### 1. [Что такое макросы на языке C?](#Что_есть_макросы?)

Макросы на языке C - это директивы препроцессора, 
которые используются для определения констант, функций и фрагментов кода. Они обозначаются символом # в начале строки.

#### 2. Каковы преимущества использования макросов на языке C?

Преимущества использования макросов на языке C включают улучшенную читаемость кода и удобство сопровождения, 
позволяя разработчикам определять и повторно использовать фрагменты кода, константы и функции. 
Они также упрощают модификацию и обновление кода путем изменения определения макроса.

#### 3. [Каковы два типа макросов на языке C?(есть ещё и виды)](#Виды_макросов)

Два типа макросов в языке C - это объектно-подобные макросы(Object-like Macro) и функционально-подобные макросы(Function-like Macro). 
Объектно-подобные макросы определяют константы или фрагменты кода, в то время как функциональные макросы определяют фрагменты кода с аргументами.

#### 4. [Какие препроцессорные операции работают с макросами?](#Препроцессорные_операции)

"#" и "##" 


"#" Превращает переданную переменную в строку(заключает её в кавычки при препроцессорной подстановки макроса)


"##" Соединяет две [лексемы](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81_%D0%B8_%D1%81%D0%B5%D0%BC%D0%B0%D0%BD%D1%82%D0%B8%D0%BA%D0%B0_%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0_%D0%A1%D0%B8)

#### 5. [Техника безопасности при работе с макросами](#Техника_безопасности_при_работе_с_макросами)

1.  Параметрами макросов не должны быть выражения и вызовы функций.
2.  Все аргументы макроса и сам макрос должны быть заключены в скобки.
3.  Многострочные макросы должны иметь свою область видимости.

#### 6. [Сайты](#Ссылки_откуда_я_это_скатал)

#### 7. [Оглавление](#Оглавление)
