# Атомики и мьютексы
____

## Что такое атомарные операции
____

**Атомарные операции** — операции, выполняющиеся как единое целое либо не выполняющиеся вовсе.
Т. е. это операция, во время исполнения которой данные, читаемые/изменяемые этой операцией не могут быть изменены другой операцией.
Есть специальные ассемблерные команды, которые указывают процессору, что операция будет атомарной.
Есть несколько типов команд, с помощью которых можно добиться атомарности: load-link and store-conditional (LL/SC), compare-and-swap (CAS) и другие.

Атомарные операции используются в многопроцессорных компьютерах и в многозадачных операционных системах для обеспечения доступа нескольких процессов и/или нескольких
потоков одного процесса к разделяемым между ними ресурсам. Атомарная операция выполняется только одним потоком.

## Правило
____

**_В любой момент времени когда два потока одновременно оперируют общей переменной, и один из них производит запись, оба потока обязаны использовать атомарные операции._**

Если вы нарушаете это правило, и каждый поток использует неатомарные операции, вы оказываетесь в ситауции, которую стандарт C++11 называет состояние гонок по данным. 
Стандарт C++11 не объясняет, почему состояние гонок плохо, однако утверждает, что в таком состоянии вы получите неопределенное поведение. 
Причина опасности таких состояний гонок, однако, очень проста: в них операции чтения и записи разорваны (torn read/write).

Операция с памятью может быть неатомарной даже на одноядерном процессоре только потому, что она использует несколько инструкций процессора.
Однако и одна инструкция процессора на некоторых платформах также может быть неатомарной. Поэтому, если вы пишите переносимый код для другой платформы, 
вы никак не можете опираться на предположение об атомарности отдельной инструкции.

## Рассмотрим несколько примеров
____
Допустим, у нас есть 64-битная глобальная переменная, инициализированная нулем.
```
uint64_t sharedValue = 0;
```
В какой-то момент времени мы присвоим ей значение:
```
void storeValue()
{
    sharedValue = 0x100000002;
}
```
Если мы скомпилируем этот код с помощью 32-битного компилятора GCC, мы получим такой машинный код:
```
$ gcc -O2 -S -masm=intel test.c
$ cat test.s
        ...
        mov     DWORD PTR sharedValue, 2
        mov     DWORD PTR sharedValue+4, 1
        ret
        ...
```
Видно, что компилятор реализовал 64-битное присваивание с помощью двух процессорных инструкций. Первая инструкция присваивае нижним 32 битам значение 0x00000002,
и вторая заносит в верхние биты значение 0x00000001. Очевидно, что такое присваивание неатомарно.
Если к переменной sharedValue одновременно пытаются получить доступ различные потоки, можно получить несколько ошибочных ситуаций:

1) Если поток, вызывающий storeValue, будет прерван между двумя инструкциями записи, то он оставит в памяти значение 0x0000000000000002 — это **разорванная операция записи**.
 Если в этот момент другой поток попытается прочитать sharedValue, он получит неправильное значение, которое никто и не собирался сохранять.
2) Более того, если записывающий поток был остановлен между инструкциями записи, а другой поток поменяет значение sharedValue перед тем,
 как первый поток возобновит работу, мы получим постоянно разорванную запись: верхняя половина значения переменной будет установлена одним потоком, а нижняя — вторым.
3) Чтобы получить разорванную запись на мультиядерных процессорах потоки даже не нужно прерывать: любой поток, выполняющийся на другом ядре, может прочитать значение переменной в момент, когда только половина нового значения записана в память.

Параллельное чтение из sharedVariable также имеет свои проблемы:
```
uint64_t loadValue()
{
    return sharedValue;
}
```
```
$ gcc -O2 -S -masm=intel test.c
$ cat test.s
        ...
        mov     eax, DWORD PTR sharedValue
        mov     edx, DWORD PTR sharedValue+4
        ret
        ...
```
Здесь таким же образом компилятор реализует чтение двумя инструкциями: сначала нижние 32 бита считываются в регистр EAX, а потом верхние 32 бита считываются в EDX. 
В этом случае, если параллельная запись будет произведена между этими двумя инструкциями, мы получим разорванную операцию считывания, даже если запись была атомарной.
## Неатомарные инструкции процессора
____

Операция с памятью может быть неатомарной даже если она выполняется одной инструкцией процессора. 
Например, в наборе инструкций ARMv7 есть инструкция strd, которая сохраняет содержимое двух 32-битных регистров в 64-битной переменной в памяти.


```
strd r0, r1, [r2]
```

На некоторых ARMv7 процессорах эта инструкция не является атомарной. Когда процессор видит такую инструкцию, он на самом деле выполняет две отдельные операции.
Другой поток, выполняющийся на другом ядре, может попасть в ситуацию разорванной записи. 
Интересно, что ситуация разорванной записи может возникнуть и на одном ядре: системное прерывание — скажем, для запланированной смены контекста потока — может возникнуть между внутренними операциями 32-битного сохранения! 
В этом случае, когда поток возобновит свою работу, он начнет выполнять инструкцию strd заново. 
## Классификация
____

Атомарность операций **может обеспечиваться аппаратно** (аппаратурой) и **программно** (программным кодом).
В первом случае используются особые машинные инструкции, атомарность выполнения которых гарантируется аппаратурой.
Во втором случае используются специальные программные средства синхронизации, с помощью которых осуществляется блокировка разделяемого ресурса;
после блокировки выполняется операция, которую требуется выполнить атомарно. Блокировка представляет собой атомарную операцию, которая либо предоставляет ресурс в пользование потоку, либо сообщает потоку о том, что ресурс уже используется другим потоком или процессом (занят).

### Машинные инструкции, выполнение которых всегда можно считать атомарным( небольшое погружение в ассемблер):
____

1) машинные инструкции для чтения данных из памяти по выровненному адресу и записи их в регистр общего назначения;
2) машинные инструкции для чтения данных из регистра общего назначения и записи их в память по выровненному адресу;
3) машинные инструкции, специально созданные для работы атомарно и обычно называемые атомарными инструкциями.

### Машинные инструкции, которые не являются атомарными:
____

1) машинные инструкции для чтения/записи данных по невыровненному адресу (выполняя одну из таких инструкций, процессор вынужден выполнить обращение к двум ячейкам памяти.
  В момент, когда процессор обращается к одной ячейке, другая ячейка может быть изменена другим процессором);
2) все машинные инструкции вида «чтение-модификация-запись» (выполнение одной такой инструкции сводится к чтению данных из памяти, изменению данных в АЛУ и записи данных в память.
 После чтения данных из памяти содержимое памяти может измениться);
3) строковые машинные инструкции процессоров x86;
4) машинные инструкции push и pop процессоров x86;
5) машинные инструкции, работающие со специальными управляющими регистрами (подобные инструкции могут выполняться в течение нескольких процессорных тактов и порождать десятки или сотни обращений к памяти, используются только в системном программном обеспечении).

## Все операции C/C++ считаются неатомарными
____
В C/C++ каждая операция считается неатомарной до тех пор, пока другое не будет явно указано прозводителем компилятора или аппаратной платформы — даже обычное 32-битное присваивание.
Стандарты языка ничего не говорят по поводу атомарности в этом случае. Возможно, целочисленное присваивание атомарно, может быть нет. Поскольку неатомарные операции не дают никаких гарантий, обычное целочисленное присваивание в C является неатомарным по определению.

На практике мы обычно обладаем некоторой информацией о платформах, для которых создается код.
Например, мы обычно знаем, что на всех современных процессорах x86, x64, Itanium, SPARC, ARM и PowerPC обычное 32-битное присваивание атомарно в том случае, 
если переменная назначения выровнена.В этом можно убедиться, перечитав соответствующий раздел документации процессора и/или компилятора.

В C++11 наконец-то появился способ выполнять действительно переносимые атомарные сохранения и загрузки. Эти операции, произведенные с помощью атомарной библиотеки C++11 будут работать даже на условном устройстве, описанном ранее: даже если это будет означать, что библиотеке прийдется блокировать мьютекс для того, чтобы сделать каждую операцию атомарной.

## Мьютексы
____

**Мьютекс* (также называют защелкой) - это механизм изоляции, используемый  для синхронизации доступа нескольких потоков к совместно используемым ресурсам.

Условно классический мьютекс можно представить в виде переменной, которая может находиться в двух состояниях: в заблокированном и в незаблокированном.
При входе в свою критическую секцию поток вызывает функцию перевода мьютекса в заблокированное состояние, при этом поток блокируется до освобождения мьютекса,
если другой поток уже владеет им. При выходе из критической секции поток вызывает функцию перевода мьютекса в незаблокированное состояние. 
В случае наличия нескольких заблокированных по мьютексу потоков во время разблокировки планировщик выбирает поток для возобновления выполнения 
(в зависимости от реализации это может быть, как случайный, так и детерминированный по некоторым критериям поток).

Задачей мьютекса является защита объекта от доступа к нему других потоков, отличных от того, который завладел мьютексом. 
В каждый конкретный момент только один поток может владеть объектом, защищённым мьютексом. 
Если другому потоку будет нужен доступ к данным, защищённым мьютексом, то этот поток блокируется до тех пор, пока мьютекс не будет освобождён. 
Мьютекс защищает данные от повреждения в результате асинхронных изменений (состояние гонки), однако при неправильном использовании могут порождаться другие проблемы, например, взаимная блокировка или двойной захват.

## Мьютексы в языке Си
____
Стандарт С17 языка программирования Си определяет тип mtx_t и набор функций для работы с ним, которые должны быть доступны,
если макрос __STDC_NO_THREADS__ не был определён компилятором. Семантика и свойства мьютексов в целом совпадают со стандартом POSIX.

Тип мьютекса определяется передачей комбинации флагов в функцию mtx_init():

1) mtx_plain — нет контроля повторного захвата тем же потоком;
2) mtx_recursive — повторные захваты тем же потоком допустимы, ведётся счётчик таких захватов;
3) mtx_timed — поддерживается захват мьютекса с возвращением ошибки по истечении указанного времени.
Возможность использования мьютексов через разделяемую память различными процессами в стандарте C17 не рассматривается.

## Полезные статьи на эту тему
____
1) https://clck.ru/33rmaz
2) https://clck.ru/SSddp
3) https://clck.ru/33rmbQ
4) https://clck.ru/33rmbh
