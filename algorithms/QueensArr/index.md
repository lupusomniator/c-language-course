# Введение
Алгоритм поиска с возвратом (backtracking) - это общий методнахождения решений задачи, в которой требуется полный перебор всех возможных вариантов в некотором множестве или с заданными ограничениями . Это позволяет решать задачи типа: "Перечислить всевозможные варианты", "Сколько существует способов" или "Существует ли решение задачи".

Основная идея алгоритма заключается в том, что на каждом шаге решения задачи выбирается какой-то вариант, а затем проверяется, удовлетворяет ли он всем условиям. Если вариант не подходит (pruned), алгоритм возвращает процесс на предыдущий шаг (backtrack) и переходит к следующему возможному варианту. Этот процесс повторяется до тех пор, пока не будет найдено решение задачи (complete) или не будут перебраны все возможные варианты (рис. 1).

![Alt-текст](https://ic.wampi.ru/2023/03/15/Screenshot_3ce2ba5a6a7f3f2a5.png "(рис. 1)")

# Алгоритмы с возвратом 

В общем случае, алгоритм поиска с возвратом работает следующим образом:

1.  Определяется множество допустимых значений для каждой переменной, участвующей в решении задачи.
2.  Выбирается переменная для изменения значения, и для каждого допустимого значения переменной проверяется выполнение всех ограничений задачи.
3.  Если все ограничения выполняются, то переходим к следующей переменной.
4.  Если все переменные приняли допустимые значения, то решение найдено.
5.  Если для текущей переменной не найдено допустимых значений, то происходит возврат к предыдущей переменной и изменение ее значения.
6.  Алгоритм продолжает перебирать значения переменных, пока не будет найдено решение или не будет определено, что решение не существует.

Существует несколько основных типов алгоритмов поиска с возвратом:

1.  Рекурсивные алгоритмы поиска с возвратом (определение из словаря: Рекурсия (сущ.) — см. рекурсия.). Рекурсивный алгоритм поиска с возвратом использует рекурсию для организации перебора всех возможных комбинаций переменных. Каждый вызов функции решает задачу для одной переменной, а затем вызывает саму себя для решения оставшихся переменных. В этом случае, происходит автоматический возврат к предыдущей переменной, когда для текущей не найдено допустимых значений. Это классический алгоритм, который используется для решения комбинаторных задач, таких как задача о 8 ферзях. 
2.  Нерекурсивные алгоритмы поиска с возвратом. Нерекурсивный алгоритм поиска с возвратом использует структуры данных, такие как стек или очередь, для хранения состояний поиска. В этом случае, каждый элемент стека или очереди соответствует переменной, которую нужно изменить. Алгоритм последовательно изменяет значения переменных и проверяет выполнение ограничений на каждом шаге. Если текущее состояние не удовлетворяет ограничениям, то алгоритм возвращает последнее сохраненное состояние и продолжает поиск дальше.

# Решение задачи расстановки ферзей
Классической задачой на эту тему является расстановка 8 ферзей на 64-клеточной шахматной доске. Её решение можно описать так:

1.  Начните с пустой доски.
2.  Разместите ферзя в первом ряду и первой колонке.
3.  Если расстановка ферзей на доске удовлетворяет всем условиям (ферзи не находятся под боем друг друга), перейдите к следующему ряду и повторите шаги 2 и 3.
4.  Если вы дошли до последнего ряда и расстановка ферзей удовлетворяет всем условиям, то вы нашли решение задачи.
5.  Если вы дошли до конца ряда и ни один вариант не удовлетворяет всем условиям, вернитесь на предыдущий шаг и попробуйте другой вариант расстановки ферзей.
6.  Если вы вернулись на первый ряд и все варианты расстановки ферзей уже были перебраны, то задача не имеет решения.

Пример, удовлетворяющий условию:
![Alt-текст](https://in-w.ru/wp-content/uploads/2019/04/8Queen.jpg "Пример")

Простая реализация на языке С:
```C
#include <stdio.h>
#include <stdbool.h>

// Размер доски
#define N 8

// Инициализация доски
void InitBoard(int board[N][N]) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            board[i][j] = 0;
        }
    }
}

// Проверка, можно ли поставить ферзя в данный ряд и столбец
bool Valid(int board[N][N], int row, int col) {
    // Проверка горизонтали и вертикали
    for (int i = 0; i < N; i++) {
        if (board[row][i] == 1) {
            return false;
        }
        if (board[i][col] == 1) {
            return false;
        }
    }
    // Проверка диагоналей
    int i, j;
    for (i = row, j = col; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 1) {
            return false;
        }
    }
    for (i = row, j = col; i >= 0 && j < N; i--, j++) {
        if (board[i][j] == 1) {
            return false;
        }
    }
    for (i = row, j = col; i < N && j < N; i++, j++) {
        if (board[i][j] == 1) {
            return false;
        }
    }
    for (i = row, j = col; i < N && j >= 0; i++, j--) {
        if (board[i][j] == 1) {
            return false;
        }
    }
    return true;
}

// Решение задачи
int Solve(int board[N][N], int row) {
    // Если все строки проверены, то решение найдено
    if (row == N) {
        return 1;
    }
    // Перебираем столбцы в текущей строке
    int count = 0;
    for (int col = 0; col < N; col++) {
        // Проверяем, можно ли поставить ферзя в данную ячейку
        if (Valid(board, row, col)) {
            // Ставим ферзя на доску
            board[row][col] = 1;
            // Рекурсивно вызываем функцию для следующей строки
            count += Solve(board, row + 1);
            // Убираем ферзя
            board[row][col] = 0;
        }
    }
    // Возвращаем количество решений
    return count;
}

// Основная функция
int main() {
    int board[N][N];
    InitBoard(board);
    int count = Solve(board, 0);
    printf("Количество решений: %d\n", count);
    return 0;
}
```

# Заключение 

## Плюсы

Алгоритмы поиска с возвратом имеют несколько преимуществ:

1. Оптимизация: В отличие от алгоритмов перебора, которые проверяют все возможные варианты, алгоритмы поиска с возвратом могут быть оптимизированы, чтобы избежать проверки бесперспективных вариантов.
2.  Поиск всевозможных решений: В некоторых случаях алгоритмы поиска с возвратом могут найти все возможные решения задачи, если таковые имеются.
3.  Деление на подзадачи: Алгоритмы поиска с возвратом могут быть разработаны с использованием отдельных подзадач, которые могут быть решены отдельно и затем объединены для решения основной задачи.

## Но у него есть и минусы...

1.  Экспоненциальная сложность: В худшем случае алгоритм может перебирать все возможные варианты комбинаций, что занимает очень много времени и ресурсов. Худшая временная сложность: O(f(n)), где f(n) - функция, описывающая максимальное количество операций, которые могут быть выполнены алгоритмом при наихудшем входе размера n.
2.  Неэффективность при переборе больного количества вариантов: Некоторые задачи могут иметь слишком много комбинаций для перебора, что делает алгоритм неэффективным.
3.  Необходимость определить базовый критерий: Для того чтобы избежать перебора всех возможных комбинаций, необходимо определить критерий остановки, когда поиск можно прекратить и вернуть лучший результат, найденный на текущий момент. Но определение такого критерия может быть непростым для некоторых задач.
4.  Выбор порядка перебора влияет на результат: Порядок выбора следующего шага может существенно влиять на результат, поскольку он может привести к раннему прерыванию поиска или наоборот, к бесконечному поиску.

Алгоритм с возвратом используется при решении и других задач, таких как задача о рюкзаке, задача о покрытии и разбиении множеств, задач о пути и др. В целом, алгоритм полезен для решения задач, которые можно сформулировать в терминах поиска оптимального решения среди множества вариантов.
