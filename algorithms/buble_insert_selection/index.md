# И снова здраствуйте, с вами ваш любимый и могучий Bydlo_Coder
## Ну, что народ, погнали погружаться в эту кроличью нору сортировочных алгоритмов.

Привествую, потомков!

Данная статья разработана именно для расширения твоего познания, чтобы ты не испачкал свои панталоны на экзамене в NSU или на собесодовании в какую-нибудь крупную компанию (например СперБанк или Gogle), где очень сильно спрашивают за ~~понятия~~ алгоритмы.
Поэтому дабы ты, мой дорогой читатель не стирал свои семейные труханы, после того, как ты забыл Buble sort, я сейчас пишу эту прекСАСНУЮ статью.
Так что же тебя ждет, спросишь ты меня.
А я отвечу:

## Только сегодня и только сейчас: 3 алгоритма сортировка по цене одного!!!

В нашей программе присутсвуют 3 алгоритма реализованных на языке ~~Боли~~ Си, а также подробное объяснение их реализации для чайников 0 уровня, нубиков и тому подобное.
Начнём!

## Buble Sort, или *как осквернить такую прекрасную вещь, как ПК, своим еритическим кодом, (данная глава взята из Еритического сборника Анти-Чистый код)*

Итак, вот представь своей неочень умной головой. У тебя есть массив чисел, тебе их надо правильно упорядочить. Что тебе прийдет на ум? Правильно просто брать  и сравнивать 2 числа. Большее вправо меньшее влево. Так и как ты это сделаешь? Пройдешься сначала один раз по всему массиву, потом второй, третий и так до n-1 раз, умничка! Грубо говоря, твои элементы (большие или меньшие) "всплывают" в конец массива.
Видишь даже на СИ это выглядит довольно просто.

void bubuleSort(int* numbers, int size) {

    for (int i = 0; i < size - 1; ++i){ // проходимся по массиву
    
        for (int j = 0; j < size - 1 - i; ++j){ // проходимя до осортированной части
        
            if (numbers[j] > numbers[j+1]){ // сравниваем и меняем
                int num = numbers[j];
                numbers[j] = numbers[j+1];
                numbers[j+1] = num;
               
            }
        }
    }
}
Сложность данного босса: стабильно o(n^2).

Этот массив сортирует в порядке возрастания. Чтобы сделать на убывание, замени > на <.

Это всё. И да это частенько спрашивают. И да я ~~лез в вики~~ знал его с самого рождения. Всё не задавай глупых вопросов.
**Следущий алгоритм!**

## Selection Sort (для тех у кого IQ как у хлебушка)

Вот тут я подумал ~~удивительно~~, а ладно.

А теперь серьёзно.

У тебя есть массив чисел. ТЫ просто берешь ищешь минимальный (максимальный) элемент в своем массиве и ставишь его на 0 место. Потом снова ищешь минимальный (максимальный) элемент и ставишь его на 1 место. И так до n-1 раз.

![image](https://user-images.githubusercontent.com/112535054/227119137-029af8c8-1867-4f77-83b7-27920c60d7c2.png)

Вот код на СИ:

void selectionSort(int * numbers, int size){

    for (int i = 0; i < size - 1; ++i){ // главный проход (перебираем все значения в массиве)

        int min = i; // индекс минимального значения (сначала приравниваем его к значению элемента)

        for (int j = i + 1; j < size; ++j){ // находим минимальный элемент
            if (numbers[j] < numbers[min]){
                min = j;
            }
        }
        // меняем значения
        int temp = numbers[i];
        numbers[i] = numbers[min];
        numbers[min] = temp;
    }
}

Сложность: ![image](https://user-images.githubusercontent.com/112535054/227126921-716cbe3d-e6ad-4181-9004-4505790a64c4.png)

Требует гораздо меньше ресурсов, чем пузырь.

Чтобы поменять порядок сортировки меняй < на >.

Я устал, я ~~ухожу~~ студент работаю три дня и три ночи без СНА и СТИПЕНДИИ. УВ-А-А-А-А-А я не отдам вам автомат, я не пойду на ВТОРУЮ пересдачу. Жву за счет Фонка. 
~~Кринж~~

Следущий алгоритм.

## insertSort (и зачем его учить если можно просто выучить и использовать Heap Sort?)

У тебя снова есть массив чисел ~~Удивительно~~.

Так короче,  знай ~~включил фонк и сейчас буит МЯСООО~~ ты просто берешь делишь массив на 2 части: отсортированную и неочень. Притом в начале работы твоей программы отсортированная часть равна 0. А потом по мере прохождения твоего 1 цикла она начинает поедать по одному элементу твою не отсортированную часть. К этому, съеденный элемент должен встать в правильном порядке внутри нашей пожирающей гусенички.  
Вот посмотри на КАРТИНКУ ~~Чуркин одобряет~~ и всё станет понятно:

![image](https://user-images.githubusercontent.com/112535054/227121752-c9ad09d9-be09-49f8-9733-4c4ddee26d8c.png)

А вот код на СИ:

void insertSort(int* numbers, int size){

    for (int i = 0; i< size; ++i){ // снова проходим по всем элементам

        int temp = numbers[i]; // запоминаем элемент, который добавляем в осортированную часть

        int numberElement = i - 1; // индекс начала нашей отсортированной части

        while(numbers[numberElement] > temp && numberElement > -1){ // начинаем проходиться по отсортированной части
            numbers[numberElement + 1] = numbers[numberElement];
            --numberElement;
        }
        numbers[numberElement + 1] = temp; // записываем элемент на правильное место в нашей плотоядной гусеничке
    }
}

Сложность: меняющаяся, если уже отсортирован, то o(n - 1), иначе o(n^2).

Ты уже знаешь, что нужно сделать, чтобы поменять направление сортировки.

## Заключение, а кого заключать я спрашиваю, кого я тут вообще пишу это один... ~~Шизофрения~~

Так зачем и для кого был написан весь этот цирк? 

Ну во-первых, мы все живем в ~~соешити~~ society. А society - это просто один большой цирк, и я, и ты, мой дорогой читатель, не зрители, а непосредственные участники всего этого тордества, под названием "жизнь в 202* годах от Рождества Христова". 

НУ а во-вторых, мне просто необходим досрочный экзамен по информатике, а на него я буду работь (тут другое слово но цензура) до конца, поэтому, чтобы вызвать хоть небольшую улыбку у семинариста, я выложился на полную катушку в творчестком плане (ну и просто по-кайфу оставить такой необычный след в истории самой лучшей группы по проге в НГУ ~~Как говориться: какой хозяин, такой и след~~, а еще я не хочу чтобы Полохин заставлял меня здесь писать про расщёски и черепашки здесь, иначе это будет число Пи).

Ну и последнее, чтобы ты, мой дорогой читатель, узнал быстро и коротко, а еще понятно, про самые простые сортировки, так как не все из нас ПРОпрограммисты, рожденные с ноутбуком в руках, с установленном на нём линуксом.

# А с вами был  Bydlo_Coder ~~что за кринж~~ мне делать ещё одну статью, так что спишемся, хорошо что не сопьёмся, хотя одно другому не мешает. ФОНК рулит.

